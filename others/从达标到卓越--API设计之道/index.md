# 从达标到卓越--API设计之道

> 原文:[从达标到卓越--API设计之道](http://taobaofed.org/blog/2017/02/16/a-guide-to-api-design/)

## 提纲擎领

如何评判一个API的设计算[好]？一言蔽之，易用。

那[易用]又是什么呢？作者的理解是**只要能够足够接近人类的日常语言和思维，并且不需要引发额外的大量思考，那就是易用**。

> Don't make me think;

具体的，根据这些年碰到的大量(反面和正面)案例，归纳出一下这些要点。按照要求从低到高的顺序如下：

- 达标: 词法和语法
    - 正确拼写
    - 准确用词
    - 注意单复数
    - 不要搞错词性
    - 处理缩写
    - 用对时态和语态
- 进阶：语义和可用性
    - 单一职责
    - 避免副作用
    - 合理设计函数参数
    - 合理运用函数重载
    - 使返回值可预期
    - 固化术语表
    - 遵循一致的API风格
- 卓越：系统性和大局观
    - 版本控制
    - 确保向下兼容
    - 设计扩展机制
    - 控制API的抽象级别
    - 收敛API集
    - 发散API集
    - 制定API的支持策略

## 达标：词法和语法

高级语言和自然语言其实相差无几，因此正确的使用(英语的)词法和语法时程序员最基本的素养。而涉及到API这种供用户调用的代码时，则尤为重要。

### 正确拼写

正确地拼写一个单词是底线，这一点无须赘述。然而API中的各种错别字现象仍屡见不鲜。

### 准确用词

中英文单词的含义并非一一对应，有时一个中文意思可以用不同的英文单词来解释，这时我们需要选择使用恰当的准确的词来描述。

比如中文的[消息]可以翻译为message、notification、news等。虽然这几个单词都可以有[消息]的意思，但它们在用法和语境场景上存在着细微差异：

- message：一般指双方通信的消息，是内容载体。而且经常有来有往、成对出现。比如postMessage()和reciveMessage();

- notification:经常用于比较短小的通知，现在甚至专指ios/Android那样的通知消息。比如new NotificationManager()。

- news:内容较长的新闻消息，比notification更重量级。比如getTopNews()。

- feed:自从RSS订阅时代出现的一个单词，现在RSS已经日薄西山，但是feed这个词被用在了更多地方。

所以，即使中文意思大体相近，也要准确的用词，从而让读者更易理解 **API**的作用和**上下文场景**。

**成对出现的正反义词不可混用**。在程序世界经常成对出现的词还有：

- in & out
- on & off
- previous & next
- forward & backward
- success & failure
- ...

总之，我们可以试着扩充英语的词汇量，使用合适的词，对我们准确描述API有很大的帮助。

### 注意单复数

所有涉及到诸如数组(Array)、集合(Collection)、列表(List)这样的数据结构，在命名时都要使用复数形式：

```js

var shopItems = []

export function getShopItems(){

}


```

同时要注意，在复数的风格上保持一致，要么所有都是-s，要么所有都是-list。

反过来，我们在涉及到诸如字典(Dictionary)、表(Map)的时候，不要用复数。

虽然这个数据结构看上去由很多key-value对组成，是个类似于集合的存在，但是[map]本身已经包含了这层意思，不需要再用复数修饰。

### 不要搞错此行

另外一个容易犯低级错误是搞错词性，即命名时拎不清名词动词形容词

### 处理缩写

对于缩写，简单不易混淆的做法是，首字母缩写词的所有字幕均大写。

```js

export function getDOMNode(){}

```

另一种缩写的情况是对长单词的简写，如btn(button),chk(checkbox),tpl(template)。

这要视具体的语言规范/开发框架而定。

### 用对事态和语态

由于我们在调用API时一般类似于[调用一条指令]，所以在语法上，一个函数命名是祈使句式，时态使用一般现在时。

但在某些情况下，我们需要使用其他时态。比如，当我们涉及到***生命周期、事件节点**。

当我们设计事件API时，也要考虑使用合适的时态，特别是希望提供精细的事件切面时。或者引入before、after这样的介词来简化

另一方面是关于语态，最好的原则就是尽量避免使用被动语态。

## 进阶： 语义和可用性

说了那么多词法和语法的注意点。不过才是达标级别而已。确保API的可用性和语义才使API真正【可用】。

### 单一职责

单一职责是软件工程中一条著名的原则，然而知易行难，一是我们对于具体业务逻辑中[职责]的划分可能存在难度，二是部分同学仍没有养成贯彻此原则的习惯。

小导函数级别的API，大到整个包，保持单一核心的职责都是很重要的一件事。

```js

// bad
component.fetchDataAndRender(url,template)


// good
var data = component.fetchData(url);

component.render(data,template);

```

如上，将混杂在一个大托函数中的两件独立事情拆分出去，保证函数(function)级别的职责单一。

更进一步地，(假设)fetchData本身更适合用另一个类(class)封装，则对原来的组件类Component再进行拆分，将不属于它的读取数据职责也分离出去：

```js

class DataManager{
    fetchData(url){}
}

class Component{
    constructor(){
        this.dataManager = new DataManager();
    }

    render(data,template){}

}

var data = component.dataManager.fetchData(url);
component.render(data,template);

```

在文件(file)层面同样如此，一个文件只编写一个类，保证文件的职责单一。

最后，视具体的业务关联度决定，是否将一簇文件做成一个包(package),或是拆成多个。

### 避免副作用

严格[无副作用的编程]几乎只出现在纯函数式程序中，现实中的OOP变成场景难免触及副作用。因此在这里所说的[避免副作用]主要指的是：

- 函数本身的运行稳定可预期
- 函数的运行不对外部环境造成意外的污染。

对于无副作用的纯函数而言，输入同样的参数，执行后总能得到相同的结果，这种幂等性使得一个函数无论在什么上下文中运行、运行多少次，最后的结果总是可预期的 -- 这让用户非常放心，不用关心函数逻辑的细节、考虑是否应该在某个特定的时机调用、记录调用的次数等等。希望我们以后设计的API不会出现这个案例中的情况：

```js

// return x.x.x.1 while call it once
this.context.getSPM();

// return x.x.x.2 while call ite twice
this.context.getSPM();

```

在这里，getSPM()用来获取每一个连接唯一的SPM码(SPM是阿里通用的埋点统计方案)。但是用法却显得诡异：每调用一次，就会返回一个不同的SPM串，于是当我们需要获得几个SPM时，就会这样写：

```js

var spm1 = this.context.getSPM()
var spm2 = this.context.getSPM()
var spm3 = this.context.getSPM()
```

虽然在实现上可以理解 -- 此函数内部维护了一个计数器，每次返回一个自增的SPM，但是这样的实现方式与这个命名看似幂等的getter型函数完全不匹配，换句话说，这使得这个API不可预期。

如何修改？一种做法是，不改变此函数内部的实现，而是将API改为Generator式的风格，通过形如SPMGenerator.next()接口来获取自增的SPM码。

另一种做法是，如果要保留原名称，可以将函数签名改为getSPM(spmD),接受一个自定义的SPM D位，然后返回整个SPM码。这样在调用时也会更明确。

除了函数内部的运行需可预期外，它对外部一旦造成不可预期的污染，那么影响将更大，而且更隐蔽。

对外部造成污染一般是两种途径：一是在函数体内部直接修改外部作用域的变量，甚至全局变量；二是通过修改实参间接影响到外部环境，如果实参是引用类型的数据结构。

曾经也有发生因为对全局变量操作而导致整个容器垮掉的情况，这里就不再展开。

如何防止此类副作用发生？本质上说，需要控制读写权限。比如：

- 模块沙箱机制，严格限定模块对外部作用域的修改；
- 对关键成员作访问控制(access control),冻结写权限等等。

### 合理设计函数参数

对一个函数来说，[函数签名]比函数本体更重要。函数名、参数设置、返回值类型，这三要素构成了完整的函数签名。而其中，参数设置对用户来说是接触最频繁，也最为关心的部分。

如何优雅地设计函数的入口参数呢？几个要点：

优化参数顺序。相关性越高的参数越要前置。

这很好理解，相关性越高的参数越重要，越要在前面出现。其实这还有两个隐含的意思，即**可省略的参数后置**，以及**为可省略的参数设定省略值**。对某些语言来说，调用的时候如果想省略实参，那么一定要为它定义缺省值，而带缺省值的参数必须后置，这是在编译层面就规定死的。而对另一部分灵活的语言来说，将可省参数后置同样是最佳实践。

第二个要点是控制参数个数。用户记不住过多的入口参数，因此，参数能省略则省略，或更进一步，**合并同类型参数**。

由于可以方便地创建Object这种符合数据结构，合并参数的这种做法在JS中尤为普遍。常见的情况是将很多配置项都包装成一个配置对象。

这样做的好处是：

- 用户虽然仍需记住参数名，但不再关心参数顺序。
- 不必担心参数列表过长，将参数合并为字典后，想增加多少参数都可以，也不用关心需要将哪些可省略的参数后置的问题。

当然，凡是有利有弊，由于缺乏顺序，就无法突出哪些是最核心的参数信息；另外，在设定参数的默认值上，会比参数列表的形式更繁琐。

### 使返回值可预期

函数的易用性体现在两方面:入口和出口。上面已经讲述了足够多关于入口的涉及事项，这一节讲出口：函数返回值。

对于getter型的函数来说，调用的直接目的就是为了获得返回值。因此我们要让返回值的类型和函数名的期望保持一致。

从这一点上来讲，要慎用ES2015中的新特性[解构赋值]

而对于setter型的函数，调用的期望是它能执行一系列指令，然后去达到一些副作用，比如存文件、改写变量值等等。因此绝大多数情况我们都选择了返回undefined/void --- 这并不总是最好的选择。

回想一下，我们在调用操作系统的命令时，系统总会返回[exit code],这让我们能够获知系统命令的执行结果如何，而不必通过其他手段去验证[这个操作到底生效了没]。因此，创建这样一种返回值风格，或可一定程度增加健壮性。

另一个选项，是让setter型API始终返回this。这是jQuery为我们带来的经典启示 -- 通过返回this,来产生一种[链式调用]的风格，简化代码并且增加可读性.

最后还有一个异类，就是异步执行的函数。只能使用callback来继续操作。使用 Promise来包装它们尤为必要。对一步操作都返回一个Promise,使整体的API风格更可预期。


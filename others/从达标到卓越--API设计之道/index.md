# 从达标到卓越--API 设计之道

> 原文:[从达标到卓越--API 设计之道](http://taobaofed.org/blog/2017/02/16/a-guide-to-api-design/)

## 提纲擎领

如何评判一个 API 的设计算[好]？一言蔽之，易用。

那[易用]又是什么呢？作者的理解是**只要能够足够接近人类的日常语言和思维，并且不需要引发额外的大量思考，那就是易用**。

> Don't make me think;

具体的，根据这些年碰到的大量(反面和正面)案例，归纳出一下这些要点。按照要求从低到高的顺序如下：

* 达标: 词法和语法
  * 正确拼写
  * 准确用词
  * 注意单复数
  * 不要搞错词性
  * 处理缩写
  * 用对时态和语态
* 进阶：语义和可用性
  * 单一职责
  * 避免副作用
  * 合理设计函数参数
  * 合理运用函数重载
  * 使返回值可预期
  * 固化术语表
  * 遵循一致的 API 风格
* 卓越：系统性和大局观
  * 版本控制
  * 确保向下兼容
  * 设计扩展机制
  * 控制 API 的抽象级别
  * 收敛 API 集
  * 发散 API 集
  * 制定 API 的支持策略

## 达标：词法和语法

高级语言和自然语言其实相差无几，因此正确的使用(英语的)词法和语法时程序员最基本的素养。而涉及到 API 这种供用户调用的代码时，则尤为重要。

### 正确拼写

正确地拼写一个单词是底线，这一点无须赘述。然而 API 中的各种错别字现象仍屡见不鲜。

### 准确用词

中英文单词的含义并非一一对应，有时一个中文意思可以用不同的英文单词来解释，这时我们需要选择使用恰当的准确的词来描述。

比如中文的[消息]可以翻译为 message、notification、news 等。虽然这几个单词都可以有[消息]的意思，但它们在用法和语境场景上存在着细微差异：

* message：一般指双方通信的消息，是内容载体。而且经常有来有往、成对出现。比如 postMessage()和 reciveMessage();

* notification:经常用于比较短小的通知，现在甚至专指 ios/Android 那样的通知消息。比如 new NotificationManager()。

* news:内容较长的新闻消息，比 notification 更重量级。比如 getTopNews()。

* feed:自从 RSS 订阅时代出现的一个单词，现在 RSS 已经日薄西山，但是 feed 这个词被用在了更多地方。

所以，即使中文意思大体相近，也要准确的用词，从而让读者更易理解 **API**的作用和**上下文场景**。

**成对出现的正反义词不可混用**。在程序世界经常成对出现的词还有：

* in & out
* on & off
* previous & next
* forward & backward
* success & failure
* ...

总之，我们可以试着扩充英语的词汇量，使用合适的词，对我们准确描述 API 有很大的帮助。

### 注意单复数

所有涉及到诸如数组(Array)、集合(Collection)、列表(List)这样的数据结构，在命名时都要使用复数形式：

```js
var shopItems = [];

export function getShopItems() {}
```

同时要注意，在复数的风格上保持一致，要么所有都是-s，要么所有都是-list。

反过来，我们在涉及到诸如字典(Dictionary)、表(Map)的时候，不要用复数。

虽然这个数据结构看上去由很多 key-value 对组成，是个类似于集合的存在，但是[map]本身已经包含了这层意思，不需要再用复数修饰。

### 不要搞错此行

另外一个容易犯低级错误是搞错词性，即命名时拎不清名词动词形容词

### 处理缩写

对于缩写，简单不易混淆的做法是，首字母缩写词的所有字幕均大写。

```js
export function getDOMNode() {}
```

另一种缩写的情况是对长单词的简写，如 btn(button),chk(checkbox),tpl(template)。

这要视具体的语言规范/开发框架而定。

### 用对事态和语态

由于我们在调用 API 时一般类似于[调用一条指令]，所以在语法上，一个函数命名是祈使句式，时态使用一般现在时。

但在某些情况下，我们需要使用其他时态。比如，当我们涉及到**\*生命周期、事件节点**。

当我们设计事件 API 时，也要考虑使用合适的时态，特别是希望提供精细的事件切面时。或者引入 before、after 这样的介词来简化

另一方面是关于语态，最好的原则就是尽量避免使用被动语态。

## 进阶： 语义和可用性

说了那么多词法和语法的注意点。不过才是达标级别而已。确保 API 的可用性和语义才使 API 真正【可用】。

### 单一职责

单一职责是软件工程中一条著名的原则，然而知易行难，一是我们对于具体业务逻辑中[职责]的划分可能存在难度，二是部分同学仍没有养成贯彻此原则的习惯。

小导函数级别的 API，大到整个包，保持单一核心的职责都是很重要的一件事。

```js
// bad
component.fetchDataAndRender(url, template);

// good
var data = component.fetchData(url);

component.render(data, template);
```

如上，将混杂在一个大托函数中的两件独立事情拆分出去，保证函数(function)级别的职责单一。

更进一步地，(假设)fetchData 本身更适合用另一个类(class)封装，则对原来的组件类 Component 再进行拆分，将不属于它的读取数据职责也分离出去：

```js
class DataManager {
  fetchData(url) {}
}

class Component {
  constructor() {
    this.dataManager = new DataManager();
  }

  render(data, template) {}
}

var data = component.dataManager.fetchData(url);
component.render(data, template);
```

在文件(file)层面同样如此，一个文件只编写一个类，保证文件的职责单一。

最后，视具体的业务关联度决定，是否将一簇文件做成一个包(package),或是拆成多个。

### 避免副作用

严格[无副作用的编程]几乎只出现在纯函数式程序中，现实中的 OOP 变成场景难免触及副作用。因此在这里所说的[避免副作用]主要指的是：

* 函数本身的运行稳定可预期
* 函数的运行不对外部环境造成意外的污染。

对于无副作用的纯函数而言，输入同样的参数，执行后总能得到相同的结果，这种幂等性使得一个函数无论在什么上下文中运行、运行多少次，最后的结果总是可预期的 -- 这让用户非常放心，不用关心函数逻辑的细节、考虑是否应该在某个特定的时机调用、记录调用的次数等等。希望我们以后设计的 API 不会出现这个案例中的情况：

```js
// return x.x.x.1 while call it once
this.context.getSPM();

// return x.x.x.2 while call ite twice
this.context.getSPM();
```

在这里，getSPM()用来获取每一个连接唯一的 SPM 码(SPM 是阿里通用的埋点统计方案)。但是用法却显得诡异：每调用一次，就会返回一个不同的 SPM 串，于是当我们需要获得几个 SPM 时，就会这样写：

```js
var spm1 = this.context.getSPM();
var spm2 = this.context.getSPM();
var spm3 = this.context.getSPM();
```

虽然在实现上可以理解 -- 此函数内部维护了一个计数器，每次返回一个自增的 SPM，但是这样的实现方式与这个命名看似幂等的 getter 型函数完全不匹配，换句话说，这使得这个 API 不可预期。

如何修改？一种做法是，不改变此函数内部的实现，而是将 API 改为 Generator 式的风格，通过形如 SPMGenerator.next()接口来获取自增的 SPM 码。

另一种做法是，如果要保留原名称，可以将函数签名改为 getSPM(spmD),接受一个自定义的 SPM D 位，然后返回整个 SPM 码。这样在调用时也会更明确。

除了函数内部的运行需可预期外，它对外部一旦造成不可预期的污染，那么影响将更大，而且更隐蔽。

对外部造成污染一般是两种途径：一是在函数体内部直接修改外部作用域的变量，甚至全局变量；二是通过修改实参间接影响到外部环境，如果实参是引用类型的数据结构。

曾经也有发生因为对全局变量操作而导致整个容器垮掉的情况，这里就不再展开。

如何防止此类副作用发生？本质上说，需要控制读写权限。比如：

* 模块沙箱机制，严格限定模块对外部作用域的修改；
* 对关键成员作访问控制(access control),冻结写权限等等。

### 合理设计函数参数

对一个函数来说，[函数签名]比函数本体更重要。函数名、参数设置、返回值类型，这三要素构成了完整的函数签名。而其中，参数设置对用户来说是接触最频繁，也最为关心的部分。

如何优雅地设计函数的入口参数呢？几个要点：

优化参数顺序。相关性越高的参数越要前置。

这很好理解，相关性越高的参数越重要，越要在前面出现。其实这还有两个隐含的意思，即**可省略的参数后置**，以及**为可省略的参数设定省略值**。对某些语言来说，调用的时候如果想省略实参，那么一定要为它定义缺省值，而带缺省值的参数必须后置，这是在编译层面就规定死的。而对另一部分灵活的语言来说，将可省参数后置同样是最佳实践。

第二个要点是控制参数个数。用户记不住过多的入口参数，因此，参数能省略则省略，或更进一步，**合并同类型参数**。

由于可以方便地创建 Object 这种符合数据结构，合并参数的这种做法在 JS 中尤为普遍。常见的情况是将很多配置项都包装成一个配置对象。

这样做的好处是：

* 用户虽然仍需记住参数名，但不再关心参数顺序。
* 不必担心参数列表过长，将参数合并为字典后，想增加多少参数都可以，也不用关心需要将哪些可省略的参数后置的问题。

当然，凡是有利有弊，由于缺乏顺序，就无法突出哪些是最核心的参数信息；另外，在设定参数的默认值上，会比参数列表的形式更繁琐。

### 使返回值可预期

函数的易用性体现在两方面:入口和出口。上面已经讲述了足够多关于入口的涉及事项，这一节讲出口：函数返回值。

对于 getter 型的函数来说，调用的直接目的就是为了获得返回值。因此我们要让返回值的类型和函数名的期望保持一致。

从这一点上来讲，要慎用 ES2015 中的新特性[解构赋值]

而对于 setter 型的函数，调用的期望是它能执行一系列指令，然后去达到一些副作用，比如存文件、改写变量值等等。因此绝大多数情况我们都选择了返回 undefined/void --- 这并不总是最好的选择。

回想一下，我们在调用操作系统的命令时，系统总会返回[exit code],这让我们能够获知系统命令的执行结果如何，而不必通过其他手段去验证[这个操作到底生效了没]。因此，创建这样一种返回值风格，或可一定程度增加健壮性。

另一个选项，是让 setter 型 API 始终返回 this。这是 jQuery 为我们带来的经典启示 -- 通过返回 this,来产生一种[链式调用]的风格，简化代码并且增加可读性.

最后还有一个异类，就是异步执行的函数。只能使用 callback 来继续操作。使用 Promise 来包装它们尤为必要。对一步操作都返回一个 Promise,使整体的 API 风格更可预期。

### 固化术语表

比如我们经常会看到 pic 和 image、path 和 url 混用的情况，稍不留神就会产生 4 种组合:

* picUrl
* picPath
* imageUrl
* imagePath
* 更糟糕的情况是 imgUrl、picUri、picURL...

所以，在一开始就要产出术语表，包括对缩写词的大小如何处理、是否有自定义的缩写等等。一个术语表可以形如:

| 标准术语 | 含义     | 禁用的非标准词        |
| -------- | -------- | --------------------- |
| pic      | 图片     | image,picture         |
| path     | 路径     | URL,url,uri           |
| on       | 绑定事件 | bind,addEventListener |
| emit     | 触发事件 | fire,trigger          |
| module   | 模块     | mod                   |

不仅在公开的 API 中要遵守术语表规范，在局部变量甚至字符串中都最好按照术语表来。

另外，对于一些创造出来的、业务特色的词汇，如果不能用英语简明地翻译，就直接用拼音：

- 淘宝 Taobao
- 微淘 Weitao
- 极有家 Jiyoujia
- ...

在这里，千万不要把[微淘]翻译为MicroTaobao。专有词已经有英文名的除外,如Tmall。

### 遵循一致的API风格

这一节算得上是一个复习章法。词法、语法、语义中的很多节都指向同一个要点：一致性。

> 一致性可以最大程度降低信息熵。

一致性能大大降低用户的学习成本，并对API产生准确的预期。

- 在词法上，提炼术语表，全局保持一致的用词，避免出现不同的但是含义相近的词。
- 在语法上，遵循统一的语法结构(主谓宾顺序，主被动语态)，避免天马行空的造句。
- 在语义上，合理运用函数的重载，提供可预期的甚至一致类型的函数入口和出口。

甚至还可以一致得更细节些，只是举些例子：

- 打log要么都用中文，要么都用英文。
- 异步接口要么都用回调，要么都改成Promise。
- 事件机制只能选择其一：object.onDoSomething = func 或 object.on('doSomething',func)。
- 所有的setter操作必须返回this;
- ...

## 卓越：系统性和大局观

### 版本控制

80%的项目开发在版本控制方面都做的很糟糕；随心所欲的版本命名、空洞诡异的提交信息、毫无规律的功能更新....人们显然需要一段时间来培养规范化开发的风度，但是至少得先保证一件事情：

> 在大版本号不变的情况下，API保证向前兼容。

这里说的[大版本号]即[语义化版本命名]\<major>.\<minor>.\<patch>中的\<major>位。

这一位改动表明API整体有很大的改动，很可能不兼容，因此用户对大版本的以来改动会慎之又慎；反之，如果API有不兼容的改动，意味着必须修改大版本号，否则用户很容易出现在例行更新依赖后整个系统跑步起来的情况，更糟糕的情况则是引发线上故障。

如果这种情况得不到改善，用户们就会选择永远不升级依赖，导致更多的潜在问题。久而久之，他们最后便会弃用这些产品。

所以，希望API的提供者们以后不会再将大版本锁定为0。

### 确保向下兼容

如果不希望对客户造成更新升级方面的困扰，我们首先要做好的就是确保API向下兼容。

首先是删除。**不要轻易删除公开发布的API**，无论之前写的多么糟糕。如果一定要删除，那么确保正确使用了[Deprecated];

对于某个不想保留的API，先不要直接删除，将其标记为@deprecated后直入下一个小版本升级。

并且在changelog中明确指出这些API即将移除。

之后，在下一个 大版本 中（比如 1.1.0 到 2.0.0）删除标记为 @deprecated 的部分，同时在 changelog 中指明它们已删除。

其次是 API 的修改。如果我们仅仅是修复 bug、重构实现、或者添加一些小特性，那自然没什么可说的；但是如果想彻底修改一个 API……比如重做入口参数、改写业务逻辑等等，建议的做法是：

- 确保原来的 API 符合「单一职责」原则，如果不是则修改之。
- 增加一个全新的 API 去实现新的需求！由于我们的 API 都遵循「单一职责」，因此一旦需要彻底修改 API，意味着新需求和原来的- 职责已经完全无法匹配，不如干脆新增一个 API。
- 视具体情况选择保留或移除旧 API，进入前面所述「删除 API」的流程。

### 设计扩展机制

不只是庞大的框架需要考虑扩展性，设计可扩展的 API 应该变成一种基本的思维方式。

### 控制API的抽象级别

API能扩展的前提是什么？是接口足够抽象。这样才能够加上各种具体的定语、装饰更多功能。

### 收敛API集

对于一整个体系的API来说，用户面对的是这个整体集合，而不是其中某几个单一的API。

我们要保证集合内的API都在一致的抽象维度上，并且适当地合并API，减少整个集合的信息量，酌情做减法。

**收敛近似意义的参数和局部变量**


**收敛近似职责的函数**。对用户暴露出太多的接口不是好事，但是一旦要合并不同的函数，是否就会破坏「单一职责」原则呢？

不，因为「单一职责」本身也要看具体的抽象层次。以下这个例子和前文「合理运用函数重载」中的例子有相似之处，但具体又有所不同。

### 发散API集

### 制定API的支持策略

我们说，一组公开的 API 是产品。而产品，一定有特定的用户群，或是全球的开发者，或仅仅是跨部门的同事；产品同时有保质期，或者说，生命周期。

面向目标用户群体，我们需要制定API的支持策略：

- 每一个大版本的支持周期是多久。
- 是否有长期稳定的API支持版本
- 如何从旧版本升级。

老旧版本很可能还在运行，但维护者已经没时间精力再去管这些历史遗物，这时明确地指出某些版本不再维护，对开发者和用户都好。当然，同时别忘了给出升级文档，指导老用户如何迁移到新版本。还有一个更好的做法是，在我们开启一个新版本之际，就确定好上一个版本的寿命终点，提前知会到用户。

还有一个技术上的注意事项，那就是：大版本间最好有明确的隔离。对于一个复杂的技术产品来说，API 只是最终直接面向用户的接口，背后还有特定的环境、工具组、依赖包等各种支撑，互相之间并不能混用。

所以，隔离大版本，制定好API支持策略，让我们的产品更专业，让用户免去后顾之忧。

## 总结

**大道至简**。程序开发和平时说话写字其实没有太大区别，无非三者 --

- 逻辑和抽象
- 领域知识
- 语感

写代码，就像写作，而设计 API 好比列提纲。勤写、勤思，了解前人的模式、套路，学习一些流行库的设计方法，掌握英语、提高语感……相信大家都能设计出卓越的 API。
